import java.util.ArrayList;

/**
 * This class will provide summary statistics of the 
 * trips generated by the LiquidMap class.
 * 
 * @author sgb
 *
 */
public class TripAnalysis {
	private ArrayList<Trip> trips;
	
	public TripAnalysis(ArrayList<Trip> trips) {
		this.trips = trips;
	}
	/**
	 * This method computes min, mean, and max time of the 
	 * trips returned by the MapBuilder class.
	 * 
	 * @return an array of type double with three elements.
	 */
	public double[] getTimeStats() {
		//setup
		double minTime = trips.get(0).computeTripTime(0, 
				trips.get(0).getPoints().size() - 1);
		double totalTime = 0.0d;
		double maxTime = trips.get(0).computeTripTime(0, 
				trips.get(0).getPoints().size() - 1);
		
		//summarize
		for (Trip trip : trips) {
			//getMin 
			if (trip.computeTripTime(0, trip.getPoints().size() - 1) < minTime) {
				minTime = trip.computeTripTime(0, trip.getPoints().size() - 1);
			}
			//get totalTime for mean
			totalTime += trip.computeTripTime(0, trip.getPoints().size() -1);
			//getMax
			if (trip.computeTripTime(0, trip.getPoints().size() - 1) > maxTime) {
				maxTime = trip.computeTripTime(0, trip.getPoints().size() - 1);
			}
			
		}
		//compute mean
		double meanTime = totalTime/trips.size();
		//compute standard deviation
		double stDev = 0.0d;
		
		for (Trip trip : trips) {
			double tripTime = trip.computeTripTime(0, trip.getPoints().size() -1);
			stDev += Math.pow(tripTime - meanTime, 2);
		}
		stDev = Math.sqrt(stDev / trips.size());
		
		final double SECONDS_TO_MINUTES = 60;
		double[] timeStats = {minTime/SECONDS_TO_MINUTES, meanTime/SECONDS_TO_MINUTES, 
				stDev/SECONDS_TO_MINUTES, maxTime/SECONDS_TO_MINUTES};
		
		return timeStats;
	}
	/**
	 * This method computes min, mean, and max distance of the 
	 * trips returned by the MapBuilder class.
	 * 
	 * @return an array of type double with three elements.
	 */
	public double[] getDistanceStats() {
		
		//setup
		double minDistance = trips.get(0).computeTripDistance(0, 
				trips.get(0).getPoints().size() - 1);
		double totalDistance = 0.0d;
		double maxDistance = trips.get(0).computeTripDistance(0, 
				trips.get(0).getPoints().size() - 1);
		
		//summarize
		for (Trip trip : trips) {
			//getMin 
			if (trip.computeTripDistance(0, trip.getPoints().size() - 1) < minDistance) {
				minDistance = trip.computeTripDistance(0, trip.getPoints().size() - 1);
			}
			//getMean
			totalDistance += trip.computeTripDistance(0, trip.getPoints().size() -1);
			//getMax
			if (trip.computeTripDistance(0, trip.getPoints().size() - 1) > maxDistance) {
				maxDistance = trip.computeTripDistance(0, trip.getPoints().size() - 1);
			}
			
		}
		//compute mean
		double meanDistance = totalDistance/trips.size();
		//compute standard deviation
		double stDev = 0.0d;

		for (Trip trip : trips) {
			double tripTime = trip.computeTripDistance(0, trip.getPoints().size() -1);
			stDev += Math.pow(tripTime - meanDistance, 2);
		}
		stDev = Math.sqrt(stDev / trips.size());
		
		final double METERS_TO_MILES = 1609.34; 
		double[] distanceStats = {minDistance/METERS_TO_MILES, meanDistance/METERS_TO_MILES, 
				stDev/METERS_TO_MILES, maxDistance/METERS_TO_MILES};
		return distanceStats;
	}
}
